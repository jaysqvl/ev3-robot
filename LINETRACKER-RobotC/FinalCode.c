#pragma config(Sensor, S1,     ColorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S4,     USonicSensor,   sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          lWheel,        tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          rWheel,        tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


const int topSpeed = 15;
const int rotateSpeedFast = 30;
const int rotateSpeedSlow = 30;

void greenAction(float &dist, int &greenBeeped);
void blueAction(float &dist, int &r, int &blueBeeped);
void chooseAction(int &lastColor, int &r, float &dist, int &beep);
void displayRGB(long redValue, long greenValue, long blueValue);
void beepStopHelper(long beepFreq, int beepLength);

// EFFECTS: displays RGB value on Robot Screen
void displayRGB(long redValue, long greenValue, long blueValue) {
	// DEBUG Display
	eraseDisplay();
	displayStringAt(0,15, "red: %d", redValue);
	displayStringAt(0,30, "blue: %d", blueValue);
	displayStringAt(0,45, "green: %d", greenValue);
}

// EFFECTS: Function abstraction, helps functions keep track of the last seen color
// lastColor == 0 is blue || lastColor == 1 is green
void chooseAction(int &lastColor, int &r, float &dist, int &beep) {
	if (lastColor == 0) {
		blueAction(dist, r, beep);
	} else {
		greenAction(dist, beep);
	}
}

// EFFECTS: Given desired beep frequency and beep length in x ms, stops the robot and beeps
//				for x amount of time
void beepStopHelper(long beepFreq, int beepLength) {
	int beepToneTime = beepLength / 10;
	
	playTone(200, beepToneTime);
	sleep(beepLength);
}

// EFFECTS: Static action done when robot sees object and currently tracking green line
void greenAction(float &dist, int &greenBeeped) {
	// push the object out of the way

	if (dist <= 10 && greenBeeped == 0) {
		//beep
		setMotorSpeed(lWheel, 0);
		setMotorSpeed(rWheel, 0);
		
		beepStopHelper(200, 2000);
		greenBeeped = 1;

		// Static action
		// move it forward
		motor[lWheel] = 30;
		motor[rWheel] = 30;
		sleep(300);

		motor[lWheel] = 20;
		motor[rWheel] = -20;
		sleep(1000);

		// move it forward
		motor[lWheel] = 30;
		motor[rWheel] = 30;
		sleep(1000);

		// move backwards
		motor[lWheel] = -30;
		motor[rWheel] = -30;
		sleep(700);

		// rotate back
		motor[lWheel] = -20;
		motor[rWheel] = 20;
		sleep(1000);

	}
}

// EFFECTS: Static action done when robot sees object and currently tracking blue line
void blueAction(float &dist, int &r, int &blueBeeped) {
	// turn around and go back to the beginning
	if (dist <= 10 && blueBeeped == 0) {

		//beep
		setMotorSpeed(lWheel, 0);
		setMotorSpeed(rWheel, 0);

		beepStopHelper(200, 2000);
		blueBeeped = 1;

		//Static Action
		// move backwards
		motor[lWheel] = -30;
		motor[rWheel] = -30;
		sleep(300);

		motor[lWheel] = -30;
		motor[rWheel] = 30;
		sleep(400);
		r = 1;
	}
}

task main()
{
	long redValue;
	long greenValue;
	long blueValue;

	float distance;
	int rotatedAlready = 0;
	int greenBeeped = 0;
	int blueBeeped = 0;
	int lastColor;

	//Keep looping forever
	while(true)
	{
		//If the color sensor senses the line (a dark value
		//lower than the calculated threshold of 50):

		getColorRGB(ColorSensor, redValue, greenValue, blueValue);

		long intens = (redValue + blueValue + greenValue) / 3;

		displayRGB(redValue, greenValue, blueValue);

		distance = getUSDistance(USonicSensor);

		/*ON THE TABLE -------------------------------------------- */
		if (redValue >= 51 && redValue <= 56 &&
			blueValue >= 56 && blueValue <= 60 &&
		greenValue >= 61 && greenValue <= 63 && intens >= 56) {
			displayStringAt(0, 75, "ON: Table or White");
			setMotorSpeed(lWheel, 0);
			setMotorSpeed(rWheel, 25);

			/*GREEN EDGE LINE -------------------------------------------- */
		} else if (redValue >= 13 && redValue <= 38 &&
			blueValue >= 27 && blueValue <= 44 &&
		greenValue >= 37 && greenValue <= 51) {
			displayStringAt(0, 75, "ON: Green Edge");
			setMotorSpeed(lWheel, topSpeed);
			setMotorSpeed(rWheel, topSpeed);
			chooseAction(lastColor, rotatedAlready, distance, greenBeeped);
			lastColor = 1;

			/*GREEN DARK -------------------------------------------- */
		} else if (redValue >= 4 && redValue <= 11 &&
			blueValue >= 17 && blueValue <= 27 &&
		greenValue >= 25 && greenValue <= 42) {
			displayStringAt(0, 75, "ON: Green Dark");
			setMotorSpeed(lWheel, 20);
			setMotorSpeed(rWheel, -80);
			chooseAction(lastColor, rotatedAlready, distance, greenBeeped);
			lastColor = 1;

			/* BLUE DARK -------------------------------------------- */
		} else if (redValue >= 4 && redValue <= 12 &&
			blueValue >= 21 && blueValue <= 31 &&
		greenValue >= 10 && greenValue <= 15) {
			displayStringAt(0, 75, "ON: Blue Dark");
			// if haven't rotated yet rotate
			if (rotatedAlready == 0 && distance <= 15) {
				chooseAction(lastColor, rotatedAlready, distance, blueBeeped);
				} else {
				// rotate right to follow the line
				setMotorSpeed(lWheel, 20);
				setMotorSpeed(rWheel, -80);
			}

			lastColor = 0;
			/* BLUE EDGE LINE --------------------------------------------*/
		} else if (redValue >= 14 && redValue <= 33 &&
			blueValue >= 28 && blueValue <= 35 &&
		greenValue >= 19 && greenValue <= 33) {
			displayStringAt(0, 75, "ON: Blue Edge");
			// if haven't rotated yet rotate
			if (rotatedAlready == 0 && distance <= 15) {
				chooseAction(lastColor, rotatedAlready, distance, blueBeeped);
				} else {
				setMotorSpeed(lWheel, topSpeed);
				setMotorSpeed(rWheel, topSpeed);
			}
			lastColor = 0;
			} else {
			setMotorSpeed(lWheel, topSpeed);
			setMotorSpeed(rWheel, 0);
			}
	}
}


